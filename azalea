#!/usr/bin/env python3

# --------------------------------------------------------------------------------------------
# azalea - A Python Minecraft Modpack manager
# --------------------------------------------------------------------------------------------
# Author: Matej Stastny
# Date: 2026-02-14 (YYYY-MM-DD)
# License: MIT
# Link: https://github.com/matejstastny/azalea
# --------------------------------------------------------------------------------------------

import argparse, json, os, sys, shutil, zipfile, hashlib, time
from pathlib import Path
from urllib.request import urlopen, Request
from urllib.error import HTTPError
from urllib.parse import quote

# ---------------- LOGGING ----------------


class Log:
    RESET = "\033[0m"
    BOLD = "\033[1m"
    RED = "\033[31m"
    GREEN = "\033[32m"
    YELLOW = "\033[33m"
    BLUE = "\033[34m"
    CYAN = "\033[36m"


def log_info(msg):
    print(f"{Log.CYAN} {msg}{Log.RESET}")


def log_ok(msg):
    print(f"{Log.GREEN} {msg}{Log.RESET}")


def log_warn(msg):
    print(f"{Log.YELLOW} {msg}{Log.RESET}")


def log_err(msg):
    print(f"{Log.RED} {msg}{Log.RESET}")


# ---------------- UI HELPERS ----------------


def clear_lines(n):
    for _ in range(n):
        sys.stdout.write("\033[1A")
        sys.stdout.write("\033[2K")
    sys.stdout.flush()


def spinner(msg, duration=0.6):
    frames = "⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏"
    end = time.time() + duration
    i = 0
    while time.time() < end:
        sys.stdout.write(f"\r{Log.BLUE}{frames[i % len(frames)]} {msg}{Log.RESET}")
        sys.stdout.flush()
        time.sleep(0.05)
        i += 1
    # Finish spinner on its own line so later logs don't overwrite it
    sys.stdout.write("\r")
    sys.stdout.write("\033[2K")
    print(f"{Log.BLUE}󱗾 {msg}{Log.RESET}")


BASE = Path(".")
CONFIG = BASE / "azalea.json"
MODS = BASE / "mods"
OVERRIDES = BASE / "overrides"

API = "https://api.modrinth.com/v2"

# ---------------- UTIL ----------------


def http_json(url):
    req = Request(url, headers={"User-Agent": "azalea/0.1"})
    with urlopen(req) as r:
        return json.loads(r.read().decode())


def ensure_dirs():
    MODS.mkdir(exist_ok=True)
    OVERRIDES.mkdir(exist_ok=True)


def load_config():
    if not CONFIG.exists():
        sys.exit("Not an Azalea pack. Run `azalea init`.")
    return json.loads(CONFIG.read_text())


def save_json(path, data):
    path.write_text(json.dumps(data, indent=2))


def safe_name(s):
    """Make a filesystem-safe name."""
    keep = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_ ."
    cleaned = "".join(c if c in keep else "-" for c in s)
    return "-".join(cleaned.strip().split())


# ---------------- MODRINTH ----------------


def search_projects(query):
    """Search Modrinth and interactively ask the user to choose."""
    data = http_json(f"{API}/search?query={quote(query)}&limit=10")
    hits = data.get("hits", [])

    if not hits:
        log_warn("No matching projects found")
        return None

    spinner("Searching Modrinth…")
    spinner("Fetching results…")

    log_info("Select a project:")
    for i, h in enumerate(hits, 1):
        title = h.get("title") or h.get("slug")
        print(f"  {Log.BOLD}{i}){Log.RESET} {title}")

    printed_lines = len(hits) + 1

    while True:
        choice = input("Enter number (or press Enter to cancel): ").strip()
        if not choice:
            return None
        if choice.isdigit() and 1 <= int(choice) <= len(hits):
            selected = hits[int(choice) - 1]
            title = selected.get("title") or selected.get("slug")

            # Remove the printed list for a cleaner modern CLI feel
            clear_lines(printed_lines + 1)

            log_ok(f"Selected: {title}")
            return selected
        log_warn("Invalid selection.")


def resolve_project(user_input):
    # If URL, extract slug
    if "modrinth.com" in user_input:
        slug = user_input.rstrip("/").split("/")[-1]
    else:
        slug = user_input

    try:
        return http_json(f"{API}/project/{slug}")
    except HTTPError as e:
        if e.code != 404:
            raise

    result = search_projects(slug)
    if not result:
        log_err("No project selected")
        sys.exit(1)

    return http_json(f"{API}/project/{result['project_id']}")


def find_best_version(project_id, mc, loader):
    spinner("Resolving compatible version")
    versions = http_json(f"{API}/project/{project_id}/version")
    matches = [
        v for v in versions if mc in v["game_versions"] and loader in v["loaders"]
    ]
    if not matches:
        return None
    return matches[0]


# ---------------- INSTALL ----------------


def install_mod(identifier, installed=None, explicit=True):
    if installed is None:
        installed = set()

    cfg = load_config()
    mc, loader = cfg["minecraft_version"], cfg["loader"]

    spinner("Resolving project")
    proj = resolve_project(identifier)
    pid, slug = proj["id"], proj["slug"]

    if slug in installed:
        existing = MODS / f"{slug}.json"
        if explicit and existing.exists():
            data = json.loads(existing.read_text())
            if not data.get("explicit", False):
                data["explicit"] = True
                save_json(existing, data)
                log_info(f"Promoted {slug} to explicit mod")
        return
    installed.add(slug)

    version = find_best_version(pid, mc, loader)
    if not version:
        log_err(f"No compatible version for {slug}")
        return

    file = version["files"][0]

    deps = [
        d["project_id"]
        for d in version["dependencies"]
        if d["dependency_type"] == "required"
    ]

    data = {
        "project_id": pid,
        "slug": slug,
        "version_id": version["id"],
        "version_number": version["version_number"],
        "side": version.get("requested_status", "both"),
        "file": {
            "url": file["url"],
            "filename": file["filename"],
            "sha512": file["hashes"]["sha512"],
        },
        "explicit": explicit,
        "dependencies": deps,
    }

    save_json(MODS / f"{slug}.json", data)
    log_ok(f"Installed {slug}")

    for dep in deps:
        install_mod(dep, installed, explicit=False)


# ---------------- REMOVE ----------------


def prune_unused_deps():
    """Remove mods that are only dependencies and no longer required."""
    mods = []
    for f in MODS.glob("*.json"):
        mods.append(json.loads(f.read_text()))

    by_id = {m["project_id"]: m for m in mods}
    needed = set(m["project_id"] for m in mods if m.get("explicit"))

    stack = list(needed)
    while stack:
        cur = stack.pop()
        mod = by_id.get(cur)
        if not mod:
            continue
        for dep in mod.get("dependencies", []):
            if dep not in needed:
                needed.add(dep)
                stack.append(dep)

    removed = []
    for f in MODS.glob("*.json"):
        data = json.loads(f.read_text())
        if data["project_id"] not in needed:
            f.unlink()
            removed.append(data["slug"])

    return removed


def remove_mod(slug):
    p = MODS / f"{slug}.json"
    if not p.exists():
        log_warn("Not installed")
        return
    p.unlink()
    log_info(f"Removed {slug}")

    removed = prune_unused_deps()
    if removed:
        log_info("Pruned unused dependencies: " + ", ".join(removed))


# ---------------- CHECK ----------------


def check(target_mc):
    cfg = load_config()
    loader = cfg["loader"]

    for f in MODS.glob("*.json"):
        mod = json.loads(f.read_text())
        versions = http_json(f"{API}/project/{mod['project_id']}/version")
        ok = any(
            target_mc in v["game_versions"] and loader in v["loaders"] for v in versions
        )
        log_info(f"{mod['slug']}: {'OK' if ok else 'BLOCKED'}")


# ---------------- EXPORT ----------------


def export():
    cfg = load_config()

    out_dir = BASE / "dist"
    out_dir.mkdir(exist_ok=True)

    pack_name = safe_name(cfg.get("name", "pack"))
    pack_ver = safe_name(cfg.get("version", "0"))
    mc_ver = safe_name(cfg.get("minecraft_version", "mc"))

    filename = f"{pack_name}-{pack_ver}-mc{mc_ver}.mrpack"
    path = out_dir / filename

    manifest = {
        "formatVersion": 1,
        "game": "minecraft",
        "versionId": cfg["version"],
        "name": cfg["name"],
        "files": [],
    }

    for f in MODS.glob("*.json"):
        mod = json.loads(f.read_text())
        manifest["files"].append(
            {
                "path": f"mods/{mod['file']['filename']}",
                "hashes": {"sha512": mod["file"]["sha512"]},
                "downloads": [mod["file"]["url"]],
                "fileSize": 0,
            }
        )

    spinner("Building mrpack archive", duration=0.8)

    with zipfile.ZipFile(path, "w") as z:
        z.writestr("modrinth.index.json", json.dumps(manifest, indent=2))

        if OVERRIDES.exists():
            for file in OVERRIDES.rglob("*"):
                if file.is_file():
                    z.write(file, f"overrides/{file.relative_to(OVERRIDES)}")

    log_ok(f"Exported {path}")


# ---------------- INIT ----------------


def init():
    if CONFIG.exists():
        log_warn("Already initialized")
        return
    ensure_dirs()
    data = {
        "name": "My Pack",
        "author": "",
        "version": "1.0.0",
        "minecraft_version": "1.21.1",
        "loader": "fabric",
        "loader_version": "",
    }
    save_json(CONFIG, data)
    log_ok("Azalea pack initialized")


# ---------------- CLI ----------------


def main():
    p = argparse.ArgumentParser(prog="azalea")
    sub = p.add_subparsers(dest="cmd")

    sub.add_parser("init")

    a = sub.add_parser("add", help="Add a Modrinth mod")
    a.add_argument("mod", help="Mod name")

    r = sub.add_parser("remove", help="Remove Modrinth mod")
    r.add_argument("slug", help="Mod slug")

    c = sub.add_parser(
        "check", help="Check if the modpack is compatible with a Minecraft version"
    )
    c.add_argument("mc", help="Target Minecraft version")

    sub.add_parser("export", help="Export to dist/ with auto name")

    args = p.parse_args()

    try:
        if args.cmd == "init":
            init()
        elif args.cmd == "add":
            install_mod(args.mod)
        elif args.cmd == "remove":
            remove_mod(args.slug)
        elif args.cmd == "check":
            check(args.mc)
        elif args.cmd == "export":
            export()
        else:
            p.print_help()
    except KeyboardInterrupt:
        sys.exit(0)


if __name__ == "__main__":
    main()
